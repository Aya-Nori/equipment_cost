<!-- python 100本ノック 学習用のファイル -->

<!--

import os
from google.colab import drive
drive.mount('/content/drive')

///   knock71   ///  ネットワークの可視化

import pandas as pd

df_links = pd.read_csv("/content/drive/My Drive/100knock/links.csv", index_col = "Node")
df_links.head()


import networkx as nx
import matplotlib.pyplot as plt

# グラフオブジェクトの作成
G = nx.Graph()

# 頂点の設定
NUM = len(df_links.index)
for i in range(NUM):
  node_no = df_links.columns[i].strip("Node")
  G.add_node(str(node_no))

# 辺の設定
for i in range(NUM):
  for j in range(NUM):
    node_name = "Node" + str(j)
    if df_links[node_name].iloc[i] == 1:
      G.add_edge(str(i), str(j))

# 描画
nx.draw_networkx(G, node_color = "k", edge_color = "k", font_color = "w")
plt.show()

ライブラリnetworkx 繋がりの可視化 1:繋がっている、2:繋がっていない
リンクの多いものを中央に配置するようノード（頂点）位置を決定して可視化
再現性はない

/// /// /// /// ///


///   knock72   ///  情報の伝播状況を可視化

import numpy as np

def determine_link(percent):
  rand_val = np.random.rand()
  if rand_val <= percent:
    return 1
  else:
      return 0
  
def simulate_percolation(num, list_active, percent_percolation):
  for i in range(num):
    if list_active[i] == 1:
      for j in range(num):
        node_name = "Node" + str(j)
        if df_links[node_name].iloc[i] == 1:
          if determine_link(percent_percolation) == 1:
            list_active[j] = 1
  return list_active

percent_percolation = 0.1
T_NUM = 36
NUM = len(df_links.index)
list_active = np.zeros(NUM)
list_active[0] = 1

list_timeSeries = []
for t in range(T_NUM):
  list_active = simulate_percolation(NUM, list_active, percent_percolation)
  list_timeSeries.append(list_active.copy())

  

  # アクティブノード可視化
def active_node_coloring(list_active):
  #print(list_timeSeries[t])
  list_color = []
  for i in range(len(list_timeSeries[t])):
    if list_timeSeries[t][i] == 1:
      list_color.append("r")
    else:
      list_color.append("k")
  #print(len(list_color))
  return list_color

# 描画、初期時
t = 0
nx.draw_networkx(G, font_color = "w", node_color = active_node_coloring(list_timeSeries[t]))
plt.show()

# 描画、11か月後
t = 11
nx.draw_networkx(G, font_color = "w", node_color = active_node_coloring(list_timeSeries[t]))
plt.show()

# 描画、35か月後
t = 35
nx.draw_networkx(G, font_color = "w", node_color = active_node_coloring(list_timeSeries[t]))
plt.show()


determine_link 確率的に伝播させるかどうかを決める
simulate_percolation でシミュレーション実施
第一引数は人数、第二引数list_activeは伝播したかどうかを1/0で表現する配列
第三引数percent_percolationは伝播する確率 percent_percolation = 0.1 は伝播確率10％を意味する
actibe_node_coloring 伝播したノードを赤色で示す関数

/// /// /// /// ///



///   knock63   ///  最適化の結果が制約条件内かどうかの確認

/// /// /// /// ///


///   knock64   ///  生産計画に関するデータの読み込み

/// /// /// /// ///


///   knock66   ///  最適化問題を解く

/// /// /// /// ///



///   knock67   ///  最適生産計画が制約条件内かどうかの確認

/// /// /// /// ///



///   knock68   ///  ロジスティクスネットワーク設計問題を解く

/// /// /// /// ///


///   knock69   ///  最適ネットワークにおける輸送コストとその内訳を計算する

/// /// /// /// ///


-->